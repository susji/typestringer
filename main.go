package main

import (
	"flag"
	"fmt"
	"os"
	"regexp"

	"github.com/susji/typestringer/generator"
)

func main() {
	var fmtstr, preamble string
	var include, ignore stringsvar
	var stdout, nopackage bool
	flag.StringVar(&fmtstr, "fmt", generator.FormatReceiver, "Format string for receiver generation")
	flag.StringVar(&preamble, "preamble", "", "String written to generated files after package declaration")
	flag.Var(&include, "include", "Type name regexp to include, may be given many times")
	flag.Var(&ignore, "ignore", "Type name regexp to ignore, may be given many times")
	flag.BoolVar(&stdout, "stdout", false, "Output generated code to stdout")
	flag.BoolVar(&nopackage, "no-package", false, `Do not generate "package <name>"`)
	flag.Parse()
	includes := []*regexp.Regexp{}
	for _, i := range include {
		includes = append(includes, regexp.MustCompile(i))
	}
	ignores := []*regexp.Regexp{}
	for _, i := range ignore {
		ignores = append(ignores, regexp.MustCompile(i))
	}
	patterns := flag.Args()
	args := os.Args[1:]
	if len(patterns) == 0 {
		patterns = []string{"."}
	}
	if len(args) == 0 {
		args = patterns
	}
	header := "// Automatically generated by typestringer with the following parameters:\n"
	for _, arg := range os.Args[1:] {
		header += "//   " + arg + "\n"
	}
	g := &generator.Generator{
		Patterns:  patterns,
		Includes:  includes,
		Ignores:   ignores,
		Format:    fmtstr,
		Preamble:  preamble,
		Header:    header,
		NoPackage: nopackage,
	}
	if stdout {
		g.Output = os.Stdout
		g.NoClose = true
	}
	if err := g.Generate(); err != nil {
		fmt.Fprintln(os.Stderr, "cannot generate:", err)
		os.Exit(1)
	}
}
